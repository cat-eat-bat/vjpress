import{_ as n,C as e,c as l,o as s,j as t,G as r,a4 as d,a as h}from"./chunks/framework.BK_Jm2_s.js";const x=JSON.parse('{"title":"常用的设计模式","description":"","frontmatter":{"title":"常用的设计模式","date":"2025-03-03T00:00:00.000Z","tags":["设计模式"],"outline":"deep"},"headers":[],"relativePath":"posts/p-java-design-patterns.md","filePath":"posts/p-java-design-patterns.md","lastUpdated":1760425712000}'),c={name:"posts/p-java-design-patterns.md"};function p(b,a,m,u,q,f){const o=e("PostMeta"),i=e("PostNav");return s(),l("div",null,[a[0]||(a[0]=t("h1",{id:"常用的设计模式",tabindex:"-1"},[h("常用的设计模式 "),t("a",{class:"header-anchor",href:"#常用的设计模式","aria-label":'Permalink to "常用的设计模式"'},"​")],-1)),r(o),a[1]||(a[1]=d(' <p>设计模式一共有23种之多，按类型可以分为 创建型模式、结构型模式、行为型模式。下面分别介绍这三类中常见的一些设计模式。</p><h2 id="创建型模式" tabindex="-1">创建型模式 <a class="header-anchor" href="#创建型模式" aria-label="Permalink to &quot;创建型模式&quot;">​</a></h2><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><h3 id="单例模式-singleton" tabindex="-1">单例模式 Singleton <a class="header-anchor" href="#单例模式-singleton" aria-label="Permalink to &quot;单例模式 Singleton&quot;">​</a></h3><h3 id="工厂模式-factory" tabindex="-1">工厂模式 Factory <a class="header-anchor" href="#工厂模式-factory" aria-label="Permalink to &quot;工厂模式 Factory&quot;">​</a></h3><h3 id="建造者模式-builder" tabindex="-1">建造者模式 Builder <a class="header-anchor" href="#建造者模式-builder" aria-label="Permalink to &quot;建造者模式 Builder&quot;">​</a></h3><h3 id="原型模式-prototype" tabindex="-1">原型模式 Prototype <a class="header-anchor" href="#原型模式-prototype" aria-label="Permalink to &quot;原型模式 Prototype&quot;">​</a></h3><h2 id="结构型模式" tabindex="-1">结构型模式 <a class="header-anchor" href="#结构型模式" aria-label="Permalink to &quot;结构型模式&quot;">​</a></h2><p>这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。</p><h3 id="适配器模式-adapter" tabindex="-1">适配器模式 Adapter <a class="header-anchor" href="#适配器模式-adapter" aria-label="Permalink to &quot;适配器模式 Adapter&quot;">​</a></h3><h3 id="代理模式-proxy" tabindex="-1">代理模式 Proxy <a class="header-anchor" href="#代理模式-proxy" aria-label="Permalink to &quot;代理模式 Proxy&quot;">​</a></h3><h3 id="装饰器模式-decorator" tabindex="-1">装饰器模式 Decorator <a class="header-anchor" href="#装饰器模式-decorator" aria-label="Permalink to &quot;装饰器模式 Decorator&quot;">​</a></h3><h3 id="组合模式-composite" tabindex="-1">组合模式 Composite <a class="header-anchor" href="#组合模式-composite" aria-label="Permalink to &quot;组合模式 Composite&quot;">​</a></h3><h3 id="外观模式-facade" tabindex="-1">外观模式 Facade <a class="header-anchor" href="#外观模式-facade" aria-label="Permalink to &quot;外观模式 Facade&quot;">​</a></h3><h3 id="桥接模式-bridge" tabindex="-1">桥接模式 Bridge <a class="header-anchor" href="#桥接模式-bridge" aria-label="Permalink to &quot;桥接模式 Bridge&quot;">​</a></h3><h2 id="行为型模式" tabindex="-1">行为型模式 <a class="header-anchor" href="#行为型模式" aria-label="Permalink to &quot;行为型模式&quot;">​</a></h2><p>这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。</p><h3 id="策略模式-strategy" tabindex="-1">策略模式 Strategy <a class="header-anchor" href="#策略模式-strategy" aria-label="Permalink to &quot;策略模式 Strategy&quot;">​</a></h3><h3 id="观察者模式-observer" tabindex="-1">观察者模式 Observer <a class="header-anchor" href="#观察者模式-observer" aria-label="Permalink to &quot;观察者模式 Observer&quot;">​</a></h3><h3 id="模板方法模式-template" tabindex="-1">模板方法模式 Template <a class="header-anchor" href="#模板方法模式-template" aria-label="Permalink to &quot;模板方法模式 Template&quot;">​</a></h3><h3 id="责任链模式-chain-of-responsibility" tabindex="-1">责任链模式 Chain of Responsibility <a class="header-anchor" href="#责任链模式-chain-of-responsibility" aria-label="Permalink to &quot;责任链模式 Chain of Responsibility&quot;">​</a></h3><h3 id="命令模式-command" tabindex="-1">命令模式 Command <a class="header-anchor" href="#命令模式-command" aria-label="Permalink to &quot;命令模式 Command&quot;">​</a></h3>',23)),r(i)])}const _=n(c,[["render",p]]);export{x as __pageData,_ as default};
