import{_ as i,C as t,c as r,o as n,j as e,G as o,a4 as d,a as c}from"./chunks/framework.BK_Jm2_s.js";const g=JSON.parse('{"title":"java中的STW","description":"","frontmatter":{"title":"java中的STW","date":"2025-03-01T00:00:00.000Z","tags":["jvm","java"],"outline":"deep"},"headers":[],"relativePath":"posts/p-java-stw.md","filePath":"posts/p-java-stw.md","lastUpdated":1760425964000}'),p={name:"posts/p-java-stw.md"};function h(T,a,u,S,_,m){const l=t("PostMeta"),s=t("PostNav");return n(),r("div",null,[a[0]||(a[0]=e("h1",{id:"java中的-stw-机制",tabindex:"-1"},[c("java中的 STW 机制 "),e("a",{class:"header-anchor",href:"#java中的-stw-机制","aria-label":'Permalink to "java中的 STW 机制"'},"​")],-1)),o(l),a[1]||(a[1]=d('<h2 id="什么是-stw" tabindex="-1">什么是 STW <a class="header-anchor" href="#什么是-stw" aria-label="Permalink to &quot;什么是 STW&quot;">​</a></h2><p>在 JVM 中，<code>STW</code>（Stop-The-World）指的是 JVM 在执行某些操作时，需要暂停所有应用程序线程的一种现象。简单来说，就是让整个应用程序 “停止运行”, 在 STW 期间，除了 JVM 自身的一些线程外，所有 Java 应用程序的线程都会被暂停，直到 STW 结束, 这会导致应用程序短暂的停顿，从而影响应用程序的响应时间和性能。</p><h2 id="发生的原因" tabindex="-1">发生的原因 <a class="header-anchor" href="#发生的原因" aria-label="Permalink to &quot;发生的原因&quot;">​</a></h2><ul><li>STW 最常见的原因是垃圾回收（GC）。当 JVM 进行垃圾回收时，需要扫描整个堆内存，标记和清除不再使用的对象。为了避免在扫描过程中对象引用发生变化，导致垃圾回收出现错误，JVM 会暂停所有应用程序线程。</li><li>除了垃圾回收外，其他一些 JVM 操作也可能导致 STW，例如： <ul><li>线程转储（Thread Dump）</li><li>堆转储（Heap Dump）</li><li>偏向锁撤销（Biased Locking Revocation）</li><li>类加载</li></ul></li></ul><h2 id="stw带来的影响" tabindex="-1">STW带来的影响 <a class="header-anchor" href="#stw带来的影响" aria-label="Permalink to &quot;STW带来的影响&quot;">​</a></h2><ul><li>导致应用程序出现停顿，影响应用程序的响应时间和用户体验</li><li>STW 的停顿时间取决于多种因素，例如堆内存的大小、垃圾回收算法的选择、以及应用程序的对象分配和回收情况</li></ul><h2 id="如何减少或避免" tabindex="-1">如何减少或避免 <a class="header-anchor" href="#如何减少或避免" aria-label="Permalink to &quot;如何减少或避免&quot;">​</a></h2><ul><li><strong>选择合适的垃圾回收器</strong>：不同的垃圾回收器具有不同的 STW 特性。例如，<code>G1</code> 和 <code>ZGC</code> 等垃圾回收器旨在减少 STW 的停顿时间</li><li><strong>优化堆内存配置</strong>：合理设置堆内存的大小和比例，可以减少垃圾回收的频率和停顿时间</li><li><strong>减少对象分配</strong>：避免频繁创建和销毁大量对象，可以减少垃圾回收的压力</li><li><strong>代码优化</strong>：优化代码结构，减少全局变量的使用，可以减少gc root的数量，从而减少gc时间</li><li><strong>使用并发gc算法</strong>：并发gc算法，在垃圾回收时，允许应用程序线程和垃圾回收线程同时运行，从而减少stw时间</li></ul>',8)),o(s)])}const W=i(p,[["render",h]]);export{g as __pageData,W as default};
