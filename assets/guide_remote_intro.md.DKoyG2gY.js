import{_ as a,c as o,o as l,a4 as d}from"./chunks/framework.CPoHb7av.js";const P=JSON.parse('{"title":"RPC 与 REST","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"guide/remote/intro.md","filePath":"guide/remote/intro.md","lastUpdated":1745559088000}'),i={name:"guide/remote/intro.md"};function c(r,e,t,n,h,u){return l(),o("div",null,e[0]||(e[0]=[d('<h1 id="rpc-与-rest" tabindex="-1">RPC 与 REST <a class="header-anchor" href="#rpc-与-rest" aria-label="Permalink to &quot;RPC 与 REST&quot;">​</a></h1><p>在微服务(或 <code>SOA</code>)架构中，服务之间的核心是通信。<code>RPC</code>（远程过程调用）和<code>REST</code>是两种常见的通信方式，各有优劣，选择哪种方式取决于具体的业务场景和需求。</p><h2 id="rpc" tabindex="-1">RPC <a class="header-anchor" href="#rpc" aria-label="Permalink to &quot;RPC&quot;">​</a></h2><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li>性能高： 直接调用远程函数，减少了协议开销，性能较好。</li><li>强类型： 接口定义明确，可以进行静态类型检查，有利于提高代码质量。</li><li>服务治理： 适用于内部服务之间的调用，可以方便地进行服务发现、负载均衡、容错等。</li></ul><h3 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h3><ul><li>同构系统： 相同技术栈，团队技术背景一致，对于服务之间的紧耦合调用，<code>RPC</code>是一种高效的选择。</li><li>性能敏感场景： <code>RPC</code>的性能优势在高并发场景下尤为明显，适用于 内部服务间频繁通信、低延迟要求高、大量数据传输</li><li>强类型需求： 需要严格的接口定义、复杂的数据结构、高度的类型安全</li></ul><h2 id="rest" tabindex="-1">REST <a class="header-anchor" href="#rest" aria-label="Permalink to &quot;REST&quot;">​</a></h2><h3 id="特点-1" tabindex="-1">特点： <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点：&quot;">​</a></h3><ul><li>简单易懂： 基于<code>HTTP</code>协议，使用<code>HTTP</code>方法（<code>GET、POST、PUT、DELETE</code>）操作资源，易于理解。</li><li>松耦合： 客户端和服务器之间耦合度低，可以独立演进。</li><li>跨平台： 几乎所有语言和平台都支持<code>HTTP</code>协议。</li></ul><h3 id="适用场景-1" tabindex="-1">适用场景： <a class="header-anchor" href="#适用场景-1" aria-label="Permalink to &quot;适用场景：&quot;">​</a></h3><ul><li>对外提供API： 面向外部客户端，需要广泛的平台支持，接口需要自描述，<code>RESTful API</code>是构建对外开放的API的标准方式</li><li>异构系统： 不同技术栈、多团队协作、松耦合架构，<code>RESTful API</code>可以方便地与不同的系统进行集成。</li></ul><h2 id="如何选择" tabindex="-1">如何选择 <a class="header-anchor" href="#如何选择" aria-label="Permalink to &quot;如何选择&quot;">​</a></h2><p>选择<code>RPC</code>还是<code>REST</code>，需要综合考虑以下因素：</p><ul><li>系统内部复杂度： 如果系统内部服务之间耦合度高，对性能要求高，可以选择<code>RPC</code>。</li><li>系统外部复杂度： 如果需要对外提供 <code>API</code>，或者系统需要与其他异构系统集成，可以选择<code>REST</code>。</li><li>团队技术栈： 团队对<code>RPC</code>或<code>REST</code>的熟悉程度也会影响选择。</li><li>未来扩展性： 考虑系统的未来发展，选择一种灵活可扩展的通信方式。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li><code>RPC</code> 更适合内部服务之间的调用，性能高、耦合度强。</li><li><code>REST</code> 更适合对外提供API，耦合度低、易于理解。</li></ul><p>一般来说，在微服务架构中，<code>RPC</code>和<code>REST</code>可以结合使用：</p><ul><li>内部服务： 主要使用<code>RPC</code>，保证高性能和服务治理。</li><li>对外<code>API</code>： 主要使用<code>REST</code>，提供标准化的接口。</li></ul>',19)]))}const T=a(i,[["render",c]]);export{P as __pageData,T as default};
