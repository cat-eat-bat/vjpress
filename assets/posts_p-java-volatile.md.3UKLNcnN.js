import{_ as t,C as i,c as h,o as p,j as a,G as n,a4 as k,a as o}from"./chunks/framework.BK_Jm2_s.js";const F=JSON.parse('{"title":"volatile 关键字解析","description":"","frontmatter":{"title":"volatile 关键字解析","date":"2025-02-12T00:00:00.000Z","tags":["java并发"],"outline":"deep"},"headers":[],"relativePath":"posts/p-java-volatile.md","filePath":"posts/p-java-volatile.md","lastUpdated":1758787375000}'),d={name:"posts/p-java-volatile.md"};function r(c,s,E,g,y,v){const l=i("PostMeta"),e=i("PostNav");return p(),h("div",null,[s[0]||(s[0]=a("h1",{id:"volatile-关键字解析",tabindex:"-1"},[o("volatile 关键字解析 "),a("a",{class:"header-anchor",href:"#volatile-关键字解析","aria-label":'Permalink to "volatile 关键字解析"'},"​")],-1)),n(l),s[1]||(s[1]=k(`<h2 id="_1-volatile-关键字的作用" tabindex="-1">1. <code>volatile</code> 关键字的作用 <a class="header-anchor" href="#_1-volatile-关键字的作用" aria-label="Permalink to &quot;1. \`volatile\` 关键字的作用&quot;">​</a></h2><p>在 Java 并发编程中，<code>volatile</code> 关键字主要有以下两个作用：</p><ul><li><strong>保证可见性：</strong> 当一个线程修改了被 <code>volatile</code> 修饰的变量的值时，其他线程能够立即看到修改后的值，而不是继续使用自己工作内存中的缓存值。</li><li><strong>禁止指令重排序：</strong> <code>volatile</code> 关键字可以防止指令重排序，保证程序的执行顺序按照代码的编写顺序执行。</li></ul><h3 id="_1-1-可见性" tabindex="-1">1.1 可见性 <a class="header-anchor" href="#_1-1-可见性" aria-label="Permalink to &quot;1.1 可见性&quot;">​</a></h3><p>在 Java 内存模型中，每个线程都有自己的工作内存，工作内存中存储了共享变量的副本。当一个线程修改了共享变量的值时，它首先会修改自己工作内存中的副本，然后才会将修改后的值写回主内存。此时，其他线程的工作内存中仍然是旧的副本，因此它们无法立即看到修改后的值。</p><p>而当一个变量被 <code>volatile</code> 修饰时，线程对该变量的修改会立即写回主内存，并且会使其他线程工作内存中该变量的副本失效。这样，其他线程在读取该变量时，会强制从主内存中读取最新值，从而保证了可见性。</p><h3 id="_1-2-禁止指令重排序" tabindex="-1">1.2 禁止指令重排序 <a class="header-anchor" href="#_1-2-禁止指令重排序" aria-label="Permalink to &quot;1.2 禁止指令重排序&quot;">​</a></h3><p>为了提高程序的执行效率，编译器和处理器可能会对指令进行重排序。但是，在多线程环境下，指令重排序可能会导致程序出现意想不到的错误。</p><p><code>volatile</code> 关键字可以防止指令重排序，保证程序的执行顺序按照代码的编写顺序执行。具体来说，<code>volatile</code> 关键字会插入内存屏障，确保在 <code>volatile</code> 变量之前的指令必须在 <code>volatile</code> 变量之后执行，并且 <code>volatile</code> 变量之后的指令必须在 <code>volatile</code> 变量之前执行。</p><h2 id="_2-volatile-关键字的用法场景" tabindex="-1">2. <code>volatile</code> 关键字的用法场景 <a class="header-anchor" href="#_2-volatile-关键字的用法场景" aria-label="Permalink to &quot;2. \`volatile\` 关键字的用法场景&quot;">​</a></h2><p><code>volatile</code> 关键字通常用于以下场景：</p><ul><li><strong>状态标志：</strong> 当一个线程需要通知其他线程某个状态发生变化时，可以使用 <code>volatile</code> 变量作为状态标志。</li><li><strong>单例模式的双重检查锁：</strong> 在实现单例模式时，可以使用 <code>volatile</code> 关键字来保证对象的可见性和防止指令重排序。</li></ul><h3 id="_2-1-状态标志" tabindex="-1">2.1 状态标志 <a class="header-anchor" href="#_2-1-状态标志" aria-label="Permalink to &quot;2.1 状态标志&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyThread</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> running </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (running) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // do something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> stopRunning</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        running </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在上面的代码中，<code>running</code> 变量被 <code>volatile</code> 修饰，用于控制线程的运行状态。当其他线程调用 <code>stopRunning()</code> 方法时，会将 <code>running</code> 变量的值设置为 <code>false</code>，此时正在运行的线程能够立即看到这个变化，并停止执行。</p><h3 id="_2-2-单例模式的双重检查锁" tabindex="-1">2.2 单例模式的双重检查锁 <a class="header-anchor" href="#_2-2-单例模式的双重检查锁" aria-label="Permalink to &quot;2.2 单例模式的双重检查锁&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> volatile</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Singleton instance;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Singleton </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Singleton result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Singleton.class) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在上面的代码中，<code>instance</code> 变量被 <code>volatile</code> 修饰，用于保证对象的可见性和防止指令重排序。这样可以确保在多线程环境下，只有一个线程能够创建 Singleton 实例。</p><h2 id="_3-注意事项" tabindex="-1">3. 注意事项 <a class="header-anchor" href="#_3-注意事项" aria-label="Permalink to &quot;3. 注意事项&quot;">​</a></h2><ul><li><code>volatile</code> 关键字只能保证变量的可见性，不能保证原子性。如果需要保证原子性，可以使用 <code>synchronized</code> 关键字或 <code>Atomic</code> 类。</li><li>过度使用 <code>volatile</code> 关键字可能会影响程序的性能，因此应该谨慎使用。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>volatile</code> 关键字是 Java 并发编程中一个重要的关键字，它可以保证变量的可见性和禁止指令重排序。合理使用 <code>volatile</code> 关键字可以有效地解决多线程环境下的并发问题。</p>`,22)),n(e)])}const A=t(d,[["render",r]]);export{F as __pageData,A as default};
